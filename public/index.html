<!DOCTYPE html>
<html>
<head>
    <style>
    /* Use styles.css file if possible */
    </style>
    <link rel="stylesheet" type="text/css" href="./styles.css" />
</head>
<body>
    <h1>D3 Cloudlines Stream Monitor</h1>
    <div id="debug">
        <span class="debug_info">
        <h2>Time to Refresh</h2><span id="debug_time_to_refresh">10</span>
        </span>
            <span class="debug_info">
        <h2>Historical Size</h2><span id="debug_historical_size">0</span>
        </span>
            <span class="debug_info">
        <h2>Stream Size</h2><span id="debug_stream_size">0</span>
        </span>
    </div>
    <div id="charts">
        <div id="tooltip">
        </div>
        <div id="cloudlines">
        </div>
    </div>
    <script type="text/javascript">
    	
    </script>
</body>
<script src="./lodash.min.js"></script>
<script src="https://d3js.org/d3.v3.min.js"></script>
<script>
    stream_data = [];
    stream_offset = 0;
    historical_data = [];
    total_data = [];
    //Very important to understand time - https://github.com/d3/d3-3.x-api-reference/blob/master/API-Reference.md#d3time-time
    timeFormat = d3.time.format('%Y-%m-%d %H:%M:%S UTC');

    //START: Data Manipulation Part
    d3.json('../history.json', function(err, json) {
        if (err) window.alert('Data Invalid');
        historical_data = json; //static data
        total_data = JSON.parse(JSON.stringify(json));
        // console.log(timeFormat.parse(historical_data[5].harvested_at));
        //start
        updateApp();
        console.log('historical data size - ', historical_data.length);
        d3.select('#debug_historical_size').text(historical_data.length);
    });

    function updateApp() {
        var data_file = '../stream.json';
        console.log('called updateApp');
        d3.json(data_file, function(err, json) {
            if (err) window.alert('stream stopped');
            stream_data = json;
            //combine history and recent elements of stream
            new_data = stream_data.slice(0, stream_data.length - stream_offset); //first n elements, left of offset
            total_data = total_data.concat(new_data);
            stream_offset += new_data.length;
            // console.log(stream_offset, total_data.length, historical_data.length);
            render(total_data);
            console.log('stream data size - ', stream_data.length);
            d3.select('#debug_stream_size').text(stream_data.length);
        });

        //call render function
    }

    function updateTimeToRefresh() {
        var time_left = parseInt(d3.select('#debug_time_to_refresh').text());
        
        d3.select('#debug_time_to_refresh').text((time_left > 0) ? time_left - 1: 10);
        if (time_left == 1) updateApp();
        setTimeout(updateTimeToRefresh, 1000);
    }
    updateTimeToRefresh();

    //END: Data Manipulation Part
    tooltip = d3.select('#tooltip');

    //Canvas Details
    var width = 1050,//960,
        height = 500,//100, //todo: change
        // margin = { top: 50, right: 300, bottom: 50, left: 50 },
        margin = {top: 10, bottom: 10, left: 10, right: 10},
        innerWidth = width - margin.left - margin.right,
        innerheight = height - margin.top - margin.bottom;

        // setup x 
        var xValue = function(d) { return timeFormat.parse(d.harvested_at); }, // data -> value
            xScale = d3.time.scale().range([0, innerWidth]), // value -> display
            xMap = function(d, i) { return xScale(xValue(d)); }, // data -> display
            xAxis = d3.svg.axis().scale(xScale).orient("bottom").tickSize(-innerheight);

        // setup y - impact score
        // var yValue = function(d) { return d.event_impact_score['overall'];}, // data -> value
        //     yScale = d3.scale.linear().range([innerheight, 0]), // value -> display
        //     yMap = function(d) { return yScale(yValue(d));}, // data -> display
        //     yAxis = d3.svg.axis().scale(yScale).orient("right").tickSize(-innerWidth);

        // setup y - category
        var yValue = function(d) { return _.get(d, 'entities[0].sector');
                var s = _.get(d, 'entities[0].sector');
            }, // data -> value
            yScale = d3.scale.ordinal().rangeRoundPoints([innerheight, 0], 2.5), // value -> display
            yMap = function(d) { return yScale(yValue(d));}, // data -> display
            yAxis = d3.svg.axis().scale(yScale).orient("right").tickSize(-innerWidth);

        //setup zoomBehaviour
        // var zoomBeh = d3.behavior.zoom()
        //     .x(xScale)
        //     // .y(y)
        //     .scaleExtent([0, 500])
        //     .on("zoom", zoom);

        // setup chart
        var svg = d3.select('#cloudlines')
            .append("svg")
                .attr('width', width)
                .attr('height', height)
            .append("g")
                .classed('zoom-parent', true)
                // .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
                // .call(zoomBeh);

        svg.append("rect")
            .attr("width", innerWidth)
            .attr("height", innerheight);

        //move to renderchart
        var xAxisGroup = svg.append('g')
            .classed("x axis", true)
            .attr("transform", "translate(0," + innerheight + ")")
            //.attr("transform","translate(" + margin.left + "," + (innerheight + margin.top) + ")")       
    
        var yAxisGroup = svg.append('g')
            .classed("y axis", true)
            .attr("transform", "translate("+innerWidth+", 0)")

        var objects = svg.append("svg")
            .classed("objects", true)
            .attr("width", innerWidth)
            .attr("height", innerheight);

        objects.append("svg:line")
            .classed("axisLine hAxisLine", true)
            .attr("x1", 0)
            .attr("y1", 0)
            .attr("x2", innerWidth)
            .attr("y2", 0)
            .attr("transform", "translate(0," + innerheight + ")");

        objects.append("svg:line")
            .classed("axisLine vAxisLine", true)
            .attr("x1", 0)
            .attr("y1", 0)
            .attr("x2", 0)
            .attr("y2", innerheight);


    function render(data) {
        //tweets
        //new Date(d.harvested_at).getTime() > new Date('2016-12-06 04:31:42 UTC').getTime()
        var mentions = data.filter(function(d) { 
            return d.event_impact_score['overall'] != null && d.article_type == 'tweet'; //&& (timeFormat.parse(d.harvested_at) > timeFormat.parse('2016-12-08 04:31:42 UTC'));
            // return true;
        });
        //renderList([""]); //re-render view, removing all elements
        //renderList(countries);
        renderChart(mentions);
    }

    function renderChart(mentions) {
        console.log('data render size -', mentions.length);

        var dotSizeScale = d3.scale.linear().range([20,1000]),
            opacityScale = d3.scale.linear().range([0,1]),
            colorScale = d3.scale.category20;

        var recentTime = d3.max(mentions, function(c){ 
            // console.log(timeFormat.parse(c.harvested_at));
            return timeFormat.parse(c.harvested_at);
        });
        // console.log(recentTime);
        recentTime.setHours(recentTime.getHours() + 1);
        recentTime.setMinutes(0); //upper hour
        // console.log([new Date(recentTime.valueOf() - 60000 * 60 * 24), recentTime])
        // xScale.base(10)
        var impact_score_domain = d3.extent(mentions, function(c) { return c.event_impact_score['overall'] });
        console.log(impact_score_domain);
        dotSizeScale.domain(impact_score_domain);
        opacityScale.domain([0, 100]);

        xScale.domain([new Date(recentTime.valueOf() - 60000 * 60 * 2 * 1), recentTime]);
        // yScale.domain([impact_score_domain[0] - 10, impact_score_domain[1] + 10]);
        //todo: sort based on article count
        yScale.domain(['Finance', 'Energy', 'Technology', 'Health Care', 'Basic Industries', 'Consumer Services']);

        // var xAxisLabel = chart1.append("text")
        //     .attr("class", "axisLabel")
        //     .attr("text-anchor", "end")
        //     .attr("x", innerWidth)
        //     .attr("y", innerheight)
        //     .text("time ...");

        xAxisGroup.call(xAxis);
        yAxisGroup.call(yAxis);

        //Render Scatter Plot
        var selection = objects.selectAll(".dot")
                            .data(mentions,function(d){ //key tied to dot
                                return d.id;
                            });
    
        selection
            .enter()
            .append("circle")
            .classed("dot", true)
            .attr("opacity", function(d, i) { return opacityScale(d.event_impact_score['overall']) })
            .attr("r", function(d, i) { 
                return Math.sqrt(dotSizeScale(d.event_impact_score['overall']) / Math.PI) 
            }) //Area radius conversion
            .attr("cx", function(d, i) { 
                return xScale(xValue(d))
            })
            .attr("cy", function(d, i) { 
                return yScale(yValue(d))
            })
            .on("mouseenter", function(d, i) {
                // highlight(d.name)
                tooltip.style({
                    visibility: "visible",
                    top: d3.event.clientY,
                    left: d3.event.clientX,
                    opacity: 1
                })
                tooltip.text(d.harvested_at)
            })
            .on("mouseleave", function(d, i) {
                // unHighlight(d.name)
                tooltip.style({
                    visibility: "hidden",
                    opacity: 0
                })
            });
            // .attr("fill", function(d, i) { return colorScale(d.event_summary['group']) })

            //TODO: fix, for some reason this part causes issues.. why? must be resolved..
            // selection.exit().remove();
            // selection.transition()
            //     .attr("r", function(d, i) { return Math.sqrt(dotSizeScale(d.event_impact_score['overall']) / Math.PI) }) //Area radius conversion
            //     .attr("cx", function(d, i) { return xScale(d.harvested_at) })
                // .attr("cy", function(d, i) { return yScale(d.lifeExpectancy[vizYear]) })
                // .attr("fill", function(d, i) { return colorScale(d.event_summary['group']) })
    }

  function zoom() {
    svg.select(".x.axis").call(xAxis);
    // svg.select(".y.axis").call(yAxis);

    svg.selectAll(".dot")
        .attr("transform", transform);
  }

  function transform(d) {
    return "translate(" + xScale(timeFormat.parse(d.harvested_at)) + ", 50)";
  }
</script>
</html>